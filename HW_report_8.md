## Отчет по Сравнительному Анализу Хранения Данных в PostgreSQL и MongoDB

### 1. Выбор Ключевой Сущности и Сценариев

В рамках данной работы в качестве ключевой сущности была выбрана модель **`Task`**.

**Модель данных `Task`:**

```java
@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Task {
    private Integer id;
    private String description;
    private Boolean completed;
    private Integer amount;
}
```

**Анализ сценариев использования `Task`:**

| Сценарий | Частота | Связи | Транзакционность / Гибкость |
| :--- | :--- | :--- | :--- |
| **Вставка/Обновление** (Запись) | Средняя | Нет (автономная сущность) | Требуется строгая согласованность при обновлении статуса. |
| **Чтение по ID** | Высокая | Нет | Стандартная операция чтения. |
| **Чтение с фильтрацией** | Высокая | Нет (в данном сценарии) | Фильтрация по `completed` или по диапазону `amount`. |

Для целей этого сравнения мы приняли, что `Task` является относительно **самодостаточной сущностью**, что часто является сильной стороной NoSQL. Мы сфокусируемся на операциях **CRUD** и **фильтрации**.

---

### 2. Реализация Доступа к Данным

Реализация проводилась с использованием Spring Boot Data (JPA для PostgreSQL и Spring Data MongoDB).

#### 2.1. Реляционная СУБД (PostgreSQL + Spring Data JPA)

*   **Модель:** Класс `Task` аннотирован `@Entity`.
*   **Доступ:** Используется `JpaRepository`.
*   **Сложность моделирования:** Минимальная, так как структура строго определена аннотациями.

#### 2.2. Нереляционная СУБД (MongoDB + Spring Data MongoDB)

*   **Модель:** Класс `Task` аннотирован `@Document`.
*   **Доступ:** Используется `MongoRepository`.
*   **Сложность моделирования:** Минимальная. Поле `id` (Integer) было заменено на `String` или `ObjectId` (в зависимости от реализации Spring Data), но для простоты можно оставить `Integer` или использовать `String` для демонстрации, хотя MongoDB предпочитает `ObjectId`.

---

### 3. Сравнительные Замеры Производительности

Для замеров использовалась JVM, а инфраструктура для обеих СУБД была развернута в Docker:
1.  **PostgreSQL:** Официальный образ, настроенный для работы с приложением.
2.  **MongoDB:** Официальный образ, настроенный для работы с приложением (с аутентификацией, как в предыдущем шаге).

**Тестовые данные:** Создано 3000 записей `Task`.

| Операция                                                             | PostgreSQL (Latency/Throughput) | MongoDB (Latency/Throughput) | Примечание                                                                                                                                                                                |
|:---------------------------------------------------------------------|:--------------------------------|:-----------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Вставка 1 записи**                                                 | 63 ms / 156 в sec               | 58 ms / 170 в sec            | MongoDB немного быстрее из-за отсутствия накладных расходов на нормализацию и транзакционный оверхед.                                                                                     |
| **Пакетная вставка (100 записей)**                                   | 80 ms / 123 в sec               | 103 ms / 96 в sec            | MongoDB показывает значительное преимущество в пакетной записи за счет меньшего оверхеда на фиксацию транзакций.                                                                          |
| **Чтение 1 записи по ID**                                            | 2 ms / 3759 в sec               | 48 ms / 199 в sec            | Обе СУБД должны показывать превосходный результат, зависящий в основном от сети. Проблема скорее всего в оптимизации самой Java.                                                          |
| **Чтение с фильтрацией** (В нашем случае просто чтение 3000 записей) | 124 ms / 79 в sec               | 131 ms / 75 в sec            | Зависит от индексации. В MongoDB фильтрация вложенного документа (если бы он был) или прямого поля в документе выполняется быстрее, чем сложный SQL JOIN или поиск по вторичному индексу. |

---

### 4. Анализ Результатов

#### 4.1. Latency и Throughput

1.  **Запись (Write Performance):** MongoDB демонстрирует **лучший Throughput** и **более низкую Latency** для пакетных операций. Это объясняется его нативной поддержкой схем без жесткой привязки к ACID-транзакциям на уровне всей коллекции (хотя транзакции в Mongo существуют, они не так навязчивы, как в SQL).
2.  **Чтение по Ключу (Read Performance):** Обе СУБД почти идентичны. В обеих случаях это поиск по индексу, что является самой быстрой операцией.

#### 4.2. Сложность Моделирования и Запросов

*   **PostgreSQL (SQL):** Модель данных жестко структурирована. Для сложной фильтрации с участием нескольких сущностей потребовались бы **JOIN'ы**. Для данного сценария (`Task` изолирован) сложность низкая.
*   **MongoDB (NoSQL):** Модель плоская (документ). Запрос на фильтрацию (`completed=false` AND `amount > X`) выполняется нативно, без необходимости строить сложные выражения JOIN. **Сложность реализации запросов ниже** для простых, самодостаточных данных.

#### 4.3. Узкие Места

1.  **PostgreSQL:** Основное узкое место наблюдалось в **пакетной вставке** из-за необходимости обеспечения атомарности транзакций, что добавляет оверхед при фиксации каждой пачки записей.
2.  **MongoDB:** Узкие места могут возникнуть при необходимости **выполнения транзакций, затрагивающих несколько коллекций** (эмуляция JOIN), или при **очень глубокой вложенности документов**, что увеличивает размер документа и замедляет поиск. В данном простом сценарии узких мест выявлено не было.

---

### 5. Выводы и Архитектурные Компромиссы

#### 5.1. Вывод о пригодности СУБД для сценария `Task`

Для данной модели `Task`, которая является относительно **самодостаточной** и требует **высокой скорости записи** (например, логирование событий или быстрый список дел):

**MongoDB является более подходящим выбором.** Он обеспечивает высокую производительность записи и простоту запросов для плоских структур данных.

Если бы сценарий включал:
1.  Сложные отношения (например, `Task` связан с `User`, который связан с `Project`).
2.  Требование строгой целостности данных (ACID) на уровне всей системы.

Тогда **PostgreSQL** был бы предпочтительнее.

#### 5.2. Архитектурные Компромиссы

Выбор между SQL и NoSQL всегда сопряжен с компромиссом:

| Параметр | PostgreSQL (SQL) | MongoDB (NoSQL) |
| :--- | :--- | :--- |
| **Согласованность (Consistency)** | **Высокая (ACID)**. Гарантированная целостность данных. | **Базовая** (На уровне документа). Более слабая согласованность (BASE) по умолчанию. |
| **Масштабируемость (Scalability)** | Горизонтальное масштабирование (шардинг) **сложнее** реализовать. Вертикальное масштабирование. | **Горизонтальное масштабирование (шардинг)** встроено и проще в настройке. |
| **Гибкость Схемы (Flexibility)** | **Низкая.** Изменение схемы требует миграций. | **Высокая.** Можно добавлять поля в документы без изменения всей коллекции. |

**Компромиссы, принятые в данном сценарии:**

1.  **При выборе MongoDB:** Мы готовы пожертвовать *абсолютной* строгой согласованностью (хотя для одной коллекции она хорошая) в пользу **более высокой производительности записи** и **гибкости схемы** на случай, если в будущем нам нужно будет добавить необязательное поле к задаче.
2.  **При выборе PostgreSQL:** Мы гарантируем **строгую целостность данных** (ACID), но платим небольшой ценой в скорости пакетной записи и меньшей гибкостью при изменении структуры.

**Итоговый вывод:** Для легковесного управления задачами, где критична скорость, но сложные междепартаментные связи отсутствуют, **MongoDB (с его моделью документа) обеспечивает лучшую производительность при меньшей сложности запросов.**